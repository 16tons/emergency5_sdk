// Copyright (C) 2012-2017 Promotion Software GmbH


//[-------------------------------------------------------]
//[ Header guard                                          ]
//[-------------------------------------------------------]
#pragma once


//[-------------------------------------------------------]
//[ Includes                                              ]
//[-------------------------------------------------------]
#include "qsf/base/manager/Manager.h"
#include "qsf/prototype/data/PrototypeHashMap.h"

#include <unordered_map>


//[-------------------------------------------------------]
//[ Forward declarations                                  ]
//[-------------------------------------------------------]
namespace qsf
{
	class ComponentManager;
}


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
namespace qsf
{


	//[-------------------------------------------------------]
	//[ Classes                                               ]
	//[-------------------------------------------------------]
	/**
	*  @brief
	*    Base class for prototype managers (including map)
	*/
	class QSF_API_EXPORT BasePrototypeManager : public Manager
	{


	//[-------------------------------------------------------]
	//[ Public definitions                                    ]
	//[-------------------------------------------------------]
	public:
		typedef std::unordered_map<uint64, uint64> UniqueIdMap;		///< Maps unique IDs, e.g. of prototypes in one prefab or object to another


	//[-------------------------------------------------------]
	//[ Public static methods                                 ]
	//[-------------------------------------------------------]
	public:
		/**
		*  @brief
		*    Fill prototype ID matching map
		*
		*  @param[in] fromPrototype
		*    Prototype whose IDs should be reused
		*  @param[in] toPrototype
		*    Prototype whose IDs should be replaced
		*  @param[out] outUniqueIdMap
		*    Receives the prototype ID matching map: <current prototype ID> -> <should be this prototype ID> (map is not cleared before adding new entries)
		*/
		static void fillIdMatchingMap(const Prototype& fromPrototype, const Prototype& toPrototype, UniqueIdMap& outUniqueIdMap);


	//[-------------------------------------------------------]
	//[ Public methods                                        ]
	//[-------------------------------------------------------]
	public:
		/**
		*  @brief
		*    Return the unique prototype manager identifier
		*
		*  @return
		*    The unique prototype manager identifier
		*/
		inline uint32 getId() const;

		/**
		*  @brief
		*    Return the component manager
		*
		*  @return
		*    The component manager, do no destroy the returned instance
		*/
		inline ComponentManager& getComponentManager() const;

		/**
		*  @brief
		*    Return a prototype instance by using its local asset ID
		*
		*  @param[in] id
		*    The prototype ID generated by "qsf::StringHash" (example: "sample/prefab/vehicle/ambulance")
		*
		*  @return
		*    The requested prototype instance, null pointer on error
		*/
		inline Prototype* getPrototypeById(uint64 id) const;

		/**
		*  @brief
		*    Return the prototype list
		*
		*  @return
		*    Reference to the internal prototype list, do not manipulate the list or destroy the prototypes
		*/
		inline const PrototypeHashMap& getPrototypes() const;

		/**
		*  @brief
		*    Generate a new unused prototype ID
		*
		*  @return
		*    The prototype ID
		*/
		uint64 generatePrototypeId();

		//[-------------------------------------------------------]
		//[ ID matching                                           ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Apply prototype ID matching map
		*
		*  @param[in] toPrototype
		*    Prototype which IDs should be replaced
		*  @param[in] uniqueIdMap
		*    The prototype ID matching map: <current prototype ID> -> <should be this prototype ID> (map is not cleared before adding new entries)
		*/
		void applyIdMatchingMap(const Prototype& toPrototype, const UniqueIdMap& uniqueIdMap);

		/**
		*  @brief
		*    Build prototype ID matching map with newly generated unique IDs as targets
		*
		*  @param[in] fromPrototype
		*    Prototype whose IDs should be reused
		*  @param[out] outUniqueIdMap
		*    Receives the prototype ID matching map: <current prototype ID> -> <newly generated prototype ID> (map is not cleared before adding new entries)
		*  @param[out] outFromPrototypes
		*    Optional output vector for the list of child prototypes inside "fromPrototype", may be a null pointer
		*  @param[in] followAllLinks
		*    When searching for child prototypes, all child link types will be recognized, if this is "true"; otherwise only hard-links are followed
		*/
		void buildIdMatchingMapWithGeneratedIds(const Prototype& fromPrototype, UniqueIdMap& outUniqueIdMap, std::vector<const Prototype*>* outFromPrototypes = nullptr, bool followAllLinks = false);

		/**
		*  @brief
		*    Build prototype ID matching map of all child prototype IDs to themselves
		*
		*  @param[in] fromPrototype
		*    Prototype whose IDs should be reused
		*  @param[out] outUniqueIdMap
		*    Receives the prototype ID matching map: <current prototype ID> -> <current prototype ID> (map is not cleared before adding new entries)
		*  @param[out] outFromPrototypes
		*    Optional output vector for the list of child prototypes inside "fromPrototype", may be a null pointer
		*  @param[in] followAllLinks
		*    When searching for child prototypes, all child link types will be recognized, if this is "true"; otherwise only hard-links are followed
		*/
		void buildIdMatchingMapWithUntranslatedIds(const Prototype& fromPrototype, UniqueIdMap& outUniqueIdMap, std::vector<const Prototype*>* outFromPrototypes = nullptr, bool followAllLinks = false);


	//[-------------------------------------------------------]
	//[ Public virtual qsf::BasePrototypeManager methods      ]
	//[-------------------------------------------------------]
	public:
		inline virtual bool containsEntities() const  { return false; }

		/**
		*  @brief
		*    Destroy a prototype instance by using its ID
		*
		*  @param[in] id
		*    The prototype's ID
		*
		*  @return
		*    "true" if all went fine, else "false" (unknown prototype identifier?)
		*
		*  @note
		*    - Does not destroy linked prototypes
		*/
		virtual bool destroyPrototypeById(uint64 id);

		/**
		*  @brief
		*    Change a prototype's ID
		*
		*  @param[in] oldId
		*    The prototype's current ID
		*  @param[in] newId
		*    The new ID to assign to the prototype
		*
		*  @return
		*    "true" if all went fine, else "false" (unknown prototype identifier?)
		*
		*  @note
		*    - Use with care: all references to the old prototype ID will become invalid
		*/
		virtual bool changePrototypeId(uint64 oldId, uint64 newId);


	//[-------------------------------------------------------]
	//[ Protected methods                                     ]
	//[-------------------------------------------------------]
	protected:
		/**
		*  @brief
		*    Constructor
		*/
		explicit BasePrototypeManager(uint32 id);

		/**
		*  @brief
		*    Destructor
		*/
		virtual ~BasePrototypeManager();

		/**
		*  @brief
		*    Reserve prototypes
		*
		*  @param[in] numberOfPrototypes
		*    Number of prototypes to reserve
		*
		*  @note
		*    - You might want to reserve prototypes before starting an insertion of prototype masses (performance)
		*/
		inline void reservePrototypes(size_t numberOfPrototypes);

		/**
		*  @brief
		*    Create a new and empty prototype instance
		*
		*  @return
		*    The created prototype instance, null pointer on error (unique prototype identifier already used?), do no destroy the returned
		*    instance and do need keep a reference to it outside the C runtime stack (use the unique prototype ID instead)
		*
		*  @note
		*    - The new prototype instance has no components at all. There's e.g. no "qsf::MetadataComponent"-instance holding the human readable
		*      unique prefab name. We have to be able to use customized "qsf::MetadataComponent"-versions, so we can't build something like that into the QSF core.
		*/
		Prototype* createPrototype();

		/**
		*  @brief
		*    Create a new and empty prototype instance
		*
		*  @param[in] id
		*    The ID to assign to the new prototype
		*
		*  @return
		*    The created prototype instance, null pointer on error (unique prototype identifier already used?), do no destroy the returned
		*    instance and do need keep a reference to it outside the C runtime stack (use the unique prototype ID instead)
		*
		*  @note
		*    - The new prototype instance has no components at all. There's e.g. no "qsf::MetadataComponent"-instance holding the human readable
		*      unique prefab name. We have to be able to use customized "qsf::MetadataComponent"-versions, so we can't build something like that into the QSF core.
		*/
		Prototype* createPrototypeById(uint64 id);

		/**
		*  @brief
		*    Unregister a prototype from this manager
		*
		*  @param[in] id
		*    The prototype's ID
		*
		*  @return
		*    "true" if all went fine, else "false" (unknown prototype identifier?)
		*
		*  @note
		*    - Use this method only if you know exactly what you're doing
		*    - The prototype will not be part of any manager afterwards, but still reference this manager
		*/
		Prototype* unregisterPrototypeById(uint64 id);

		/**
		*  @brief
		*    Unregister all prototypes, i.e. clear internal management
		*
		*  @note
		*    - Use this method only if you know exactly what you're doing
		*    - The prototypes won't get destroyed; also, they will still reference this manager
		*/
		void unregisterAllPrototypes();


	//[-------------------------------------------------------]
	//[ Protected virtual qsf::BasePrototypeManager methods   ]
	//[-------------------------------------------------------]
	protected:
		virtual Prototype* createPrototypeInstance(uint64 id) = 0;
		virtual uint64 generatePrototypeIdInternal() = 0;


	//[-------------------------------------------------------]
	//[ Protected methods                                     ]
	//[-------------------------------------------------------]
	protected:
		void pushLastPrototypeToFront();


	//[-------------------------------------------------------]
	//[ Private static methods                                ]
	//[-------------------------------------------------------]
	private:
		/**
		*  @brief
		*    Fill prototype ID matching map recursively
		*
		*  @param[in] fromPrototype
		*    Prototype which IDs should be reused
		*  @param[in] toPrototype
		*    Prototype which IDs should be replaced
		*  @param[out] outUniqueIdMap
		*    Receives the prototype ID matching map: <current prototype ID> -> <should be this prototype ID> (map is not cleared before adding new entries)
		*/
		static void fillIdMatchingMapRecursively(const Prototype& fromPrototype, const Prototype& toPrototype, UniqueIdMap& outUniqueIdMap);


	//[-------------------------------------------------------]
	//[ Private methods                                       ]
	//[-------------------------------------------------------]
	private:
		void buildIdMatchingMapInternal(const Prototype& fromPrototype, UniqueIdMap& outUniqueIdMap, std::vector<const Prototype*>* outFromPrototypes, bool followAllLinks, bool generateNewIds);


	//[-------------------------------------------------------]
	//[ Private data                                          ]
	//[-------------------------------------------------------]
	private:
		uint32				mId;				///< Unique prototype manager identifier
		PrototypeHashMap	mPrototypes;		///< Prototype management data structure, basically a map with unique prototype identifier as key and pointer to the prototype as value
		ComponentManager&	mComponentManager;	///< Component manager instance, always valid, we're responsible for destroying the instance in case we no longer need it


	};


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
} // qsf


//[-------------------------------------------------------]
//[ Implementation                                        ]
//[-------------------------------------------------------]
#include "qsf/prototype/BasePrototypeManager-inl.h"
