// Copyright (C) 2012-2017 Promotion Software GmbH


//[-------------------------------------------------------]
//[ Header guard                                          ]
//[-------------------------------------------------------]
#pragma once


//[-------------------------------------------------------]
//[ Includes                                              ]
//[-------------------------------------------------------]
#include "qsf/math/BitFlagSet.h"
#include "qsf/reflection/object/Object.h"
#include "qsf/reflection/type/CampUint64.h"	// The 64 bit unsigned integer ID of the prototype class is connected to the CAMP reflection system, so we need this header to tell CAMP about this data type
#include "qsf/reflection/type/CampStringHash.h"
#include "qsf/base/WeakPtr.h"

#include <unordered_map>
#include <vector>


//[-------------------------------------------------------]
//[ Forward declarations                                  ]
//[-------------------------------------------------------]
namespace camp
{
	class Class;
	class UserObject;
}
namespace qsf
{
	class Component;
	class ComponentManager;
	class BasePrototypeManager;
	class TransformComponent;
	class Transform;
	class BinarySerializer;
}


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
namespace qsf
{


	//[-------------------------------------------------------]
	//[ Classes                                               ]
	//[-------------------------------------------------------]
	/**
	*  @brief
	*    Prototype class
	*
	*  @remarks
	*    The following example shows how to get the instance of a certain component:
	*    @code
	*    // qsf::Prototype* prototype ...
	*    qsf::MetadataComponent* qsfMetadataComponent = prototype->getComponent<qsf::MetadataComponent>();
	*    @endcode
	*    Beside this template method, one can also write:
	*    @code
	*    // qsf::Prototype* prototype ...
	*    qsf::MetadataComponent* qsfMetadataComponent = static_cast<qsf::MetadataComponent*>(prototype->getComponentById("qsf::MetadataComponent"))
	*    @endcode
	*    In this case, the unique component identifier is automatically generated by using the "qsf::StringHash"-class for compile-time string hashing.
	*    This means that usually there should be no performance drawback in using human readable identifiers instead of the hash result directly as in
	*    @code
	*    // qsf::Prototype* prototype ...
	*    qsf::MetadataComponent* qsfMetadataComponent = static_cast<qsf::MetadataComponent*>(prototype->getComponentById(483975945))
	*    @endcode
	*
	*    @code
	*    // qsf::Prototype* prototype ...
	*    qsf::MetadataComponent* qsfMetadataComponent = static_cast<qsf::MetadataComponent*>(prototype->getComponentById(483975945))
	*    @endcode
	*
	*    In case the component is derived from another component, it's also possible to get the component by using the base component ID within the
	*    request. "qsf::Component" is excluded from this. For example, "qsf::MeshComponent" also registers itself under "qsf::RendererComponent".
	*    As a result, when there's e.g. an "qsf::MeshComponent" component instance, it's not possible to add another renderer component like
	*    "qsf::ParticlesComponent".
	*
	*  @note
	*    - A prototype is just a collection of components
	*    - "Prefabs" are formed by linking prototypes together
	*    - A prefab can be identical to a prototype, or consist of multiple prototypes linked together in order to form a more complex structure
	*    - The order of the component instances inside the prototype does not matter
	*    - There can only be one instance of each component class at one and the same time
	*    - The prototype is responsible for creating and destroying it's component instances, no one else
	*    - For performance reasons, during runtime components should only be addressed by using the unique component class identifiers
	*    - This class is using the prototype design pattern as described within the book
	*      "Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. ISBN 0-201-63361-2."
	*
	*  @todo
	*    - TODO(co) Is the current implementation sufficient, or do we need something more sophisticated like the system described
	*      within the article "Managing Decoupling Part 4 — The ID Lookup Table" from Niklas Frykholm? ( http://bitsquid.blogspot.de/2011/09/managing-decoupling-part-4-id-lookup.html )
	*    - TODO(co) We could also add a "system" per "component" taking care of efficient memory management of component instances. This way we could reduce frequent new/delete when creating/destroying component instances.
	*/
	class QSF_API_EXPORT Prototype : public Object, public WeakPtrTarget
	{


	//[-------------------------------------------------------]
	//[ Friends                                               ]
	//[-------------------------------------------------------]
	friend class Component;
	friend class TransformComponent;
	friend class PrototypeManager;
	friend class BasePrototypeManager;
	friend class Layer;


	//[-------------------------------------------------------]
	//[ Public methods                                        ]
	//[-------------------------------------------------------]
	public:
		/**
		*  @brief
		*    Destructor
		*
		*  @note
		*    - Do never destroy a prototype manually, use "qsf::PrototypeManager::destroyPrototypeById()" instead
		*/
		virtual ~Prototype();

		/**
		*  @brief
		*    Return the unique prototype identifier
		*
		*  @return
		*    The unique prototype identifier
		*
		*  @note
		*    - Connected to the CAMP reflection system
		*/
		inline uint64 getId() const;

		/**
		*  @brief
		*    Return the prototype manager this prototype is in
		*
		*  @return
		*    The prototype manager this prototype is in, do no destroy the returned instance
		*/
		inline BasePrototypeManager& getPrototypeManager() const;

		/**
		*  @brief
		*    Return the component manager that's responsible for this component instance
		*
		*  @return
		*    The component manager; do not destroy the returned instance
		*/
		ComponentManager& getComponentManager() const;

		//[-------------------------------------------------------]
		//[ Component                                             ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Reserve components
		*
		*  @param[in] numberOfComponents
		*    Number of components to reserve
		*
		*  @note
		*    - You might want to reserve components before starting an insertion of component masses (performance)
		*/
		inline void reserveComponents(size_t numberOfComponents);

		/**
		*  @brief
		*    Create an instance of a component of a certain type
		*
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*/
		template <typename T> T* createComponent(bool startup = true);

		/**
		*  @brief
		*    Create an instance of a component by using its unique identifier
		*
		*  @param[in] id
		*    The unique component identifier generated by "qsf::StringHash"
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*/
		inline Component* createComponentById(const StringHash& id, bool startup = true);

		/**
		*  @brief
		*    Create an instance of a component by using a given CAMP reflection class
		*
		*  @param[in] campClass
		*    CAMP reflection class of the component to instantiate
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*/
		Component* createComponentByCampClass(const camp::Class& campClass, bool startup = true);

		/**
		*  @brief
		*    Create an instance of a component of a certain type and set component property values at once
		*
		*  @param[in] values
		*    UTF-8 property values to set (e.g. "Name=\"Alice\" Description=\"This is the test entity Alice\"")
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*    - Don't use this generic method in highly performance critical situations
		*/
		template <typename T> T* createComponentWithValues(const std::string& values, bool startup = true);

		/**
		*  @brief
		*    Create an instance of a component by using its unique identifier and set component property values at once
		*
		*  @param[in] id
		*    The unique component identifier generated by "qsf::StringHash"
		*  @param[in] values
		*    UTF-8 property values to set (e.g. "Name=\"Alice\" Description=\"This is the test entity Alice\"")
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*    - Don't use this generic method in highly performance critical situations
		*/
		inline Component* createComponentByIdWithValues(const StringHash& id, const std::string& values, bool startup = true);

		/**
		*  @brief
		*    Create an instance of a component by using a given CAMP reflection class and set component property values at once
		*
		*  @param[in] campClass
		*    CAMP reflection class of the component to instantiate
		*  @param[in] values
		*    UTF-8 property values to set (e.g. "Name=\"Alice\" Description=\"This is the test entity Alice\"")
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The created component instance, null pointer on error (maybe the component exists?), do not destroy the returned
		*    instance and do not keep a reference to it outside the C runtime stack (use the unique component ID instead)
		*
		*  @note
		*    - Before creating a new component instance, you might want to check whether or not there's already an instance of this component
		*    - Don't use this generic method in highly performance critical situations
		*/
		Component* createComponentByCampClassWithValues(const camp::Class& campClass, const std::string& values, bool startup = true);

		/**
		*  @brief
		*    Destroy a component instance
		*
		*  @param[in] component
		*    The component to destroy
		*
		*  @return
		*    "true" if all went fine, "false" if component was not part of this prototype
		*/
		bool destroyComponent(Component& component);

		/**
		*  @brief
		*    Destroy a component instance of a certain type
		*
		*  @return
		*    "true" if component was successfully destroyed, "false" if component of the given type was not present in this prototype
		*/
		template <typename T> bool destroyComponent();

		/**
		*  @brief
		*    Destroy a component instance by using its unique identifier
		*
		*  @param[in] id
		*    The unique component identifier generated by "qsf::StringHash"
		*
		*  @return
		*    "true" if component was successfully destroyed, "false" if component of the given type was not present in this prototype
		*/
		bool destroyComponentById(const StringHash& id);

		/**
		*  @brief
		*    Destroy a component instance by using a given CAMP reflection class
		*
		*  @param[in] campClass
		*    CAMP reflection class of the component to destroy
		*
		*  @return
		*    "true" if all went fine, else "false" (unknown component identifier?)
		*
		*  @note
		*    - Less efficient as e.g. qsf::Prototype::destroyComponentById()"
		*/
		bool destroyComponentByCampClass(const camp::Class& campClass);

		/**
		*  @brief
		*    Destroy all components within this prototype
		*/
		void destroyAllComponents();

		/**
		*  @brief
		*    Return a component instance of a certain type
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*/
		template <typename T> T* getComponent() const;

		/**
		*  @brief
		*    Return a component instance of a certain type
		*
		*  @return
		*    The requested component instance
		*
		*  @note
		*    - In case the instance does not exist, this method will throw an exception
		*/
		template <typename T> T& getComponentSafe() const;

		/**
		*  @brief
		*    Return a component instance pointer by using its unique identifier
		*
		*  @param[in] id
		*    The unique component identifier generated by "qsf::StringHash"
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*/
		inline Component* getComponentById(const StringHash& id) const;

		/**
		*  @brief
		*    Return a component instance by using a given CAMP reflection class
		*
		*  @param[in] campClass
		*    CAMP reflection class of the component to return
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*
		*  @note
		*    - Less efficient as e.g. qsf::Prototype::getComponentById()"
		*/
		Component* getComponentByCampClass(const camp::Class& campClass) const;

		/**
		*  @brief
		*    Return a component instance of a certain type, creates an component instance in case it does not exist
		*
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*
		*  @note
		*    - This is only an ease of use method, avoid using it if you can and use "qsf::Component::createComponentById()" instead
		*/
		template <typename T> T* getOrCreateComponent(bool startup = true);

		/**
		*  @brief
		*    Return a component instance by using its unique identifier, creates an component instance in case it does not exist
		*
		*  @param[in] id
		*    The unique component identifier generated by "qsf::StringHash"
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*
		*  @note
		*    - This is only an ease of use method, avoid using it if you can and use "qsf::Component::getComponentById()" instead
		*/
		Component* getOrCreateComponentById(const StringHash& id, bool startup = true);

		/**
		*  @brief
		*    Return a component instance by using a given CAMP reflection class, creates an component instance in case it does not exist
		*
		*  @param[in] campClass
		*    CAMP reflection class of the component to return or create
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The requested component instance, null pointer on error, do no destroy the returned instance
		*
		*  @note
		*    - This is only an ease of use method, avoid using it if you can and use "qsf::Component::getComponentById()" instead
		*    - Less efficient as e.g. qsf::Prototype::getOrCreateComponentById()"
		*/
		Component* getOrCreateComponentByCampClass(const camp::Class& campClass, bool startup = true);

		/**
		*  @brief
		*    Return a component instance of a certain type, creates a component instance in case it does not exist
		*
		*  @param[in] startup
		*    Startup the created component instance?
		*
		*  @return
		*    The requested component instance as a reference, do no destroy the returned instance
		*
		*  @note
		*    - This is only an ease of use method, avoid using it if you can and use "qsf::Component::createComponentById()" instead
		*    - In case the instance did not exist and could not be created, this method will throw an exception
		*/
		template <typename T> T& getOrCreateComponentSafe(bool startup = true);

		/**
		*  @brief
		*    Clone a component from a another one
		*
		*  @param[in] sourceComponent
		*    The original component that will be cloned
		*  @param[in] startup
		*    Startup the created component instance?
		*  @param[in] copyOverrideState
		*    If "true", the component properties' override flags will be copied as well
		*
		*  @return
		*    The created component, or a null pointer on error
		*/
		Component* cloneComponent(const Component& sourceComponent, bool startup = true, bool copyOverrideState = false);

		/**
		*  @brief
		*    Check whether a component or a conflicting component is registered already, including base classes (except "qsf::Component")
		*
		*  @param[in] componentId
		*    ID of the component to check (e.g. qsf::StringHash("qsf::MetadataComponent") generating the hash value 483975945)
		*
		*  @return
		*    In case the component is registered already, the registered component instance is returned, or a null pointer if the component is not registered
		*
		*  @note
		*    - For example "qsf::MeshComponent" also registers itself under "qsf::RendererComponent"
		*    - The same is true for "qsf::LightComponent", which would conflict with "qsf::MeshComponent" for that reason
		*/
		Component* getConflictingRegisteredComponent(uint32 componentId) const;

		/**
		*  @brief
		*    Return the component list
		*
		*  @return
		*    Reference to the internal component list, do not manipulate the list or destroy the components
		*/
		inline const std::vector<Component*>& getComponents() const;

		/**
		*  @brief
		*    Set all CAMP reflection system properties of all components to their default values
		*
		*  @note
		*    - Don't use this method in highly performance critical situations
		*/
		void setComponentPropertiesToDefaultValues();

		/**
		*  @brief
		*    Return the base prototype this prototype inherits default values for its properties from
		*
		*  @return
		*    The prototype this prototype was originally cloned from; can be a null pointer, do no destroy the returned instance
		*/
		Prototype* getBasePrototype() const;

		/**
		*  @brief
		*    Return whether or not this is an entity
		*
		*  @return
		*    Returns true if this prototype is of the entity sub-class, false if not
		*/
		inline bool isEntity() const;

		inline bool getIgnorePropertyChanges() const;
		inline void setIgnorePropertyChanges(bool ignorePropertyChanges);

		//[-------------------------------------------------------]
		//[ Serialization                                         ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Serialize or deserialize the prototype's list of components (but not their content) using a binary serializer
		*
		*  @param[in] serializer
		*    The serializer, which can be either in read or write mode
		*/
		void serializeStructure(BinarySerializer& serializer);

		/**
		*  @brief
		*    Serialize or deserialize the prototype's components using a binary serializer
		*
		*  @param[in] serializer
		*    The serializer, which can be either in read or write mode
		*/
		void serializeContent(BinarySerializer& serializer);

		/**
		*  @brief
		*    Clone all components of another prototype
		*
		*  @param[in] originalPrototype
		*    The prototype instance that will be cloned
		*  @param[in] copyOverrideState
		*    If "true", the component properties' override flags will be copied as well
		*
		*  @note
		*    - Existing components in this prototype will be deleted first
		*    - For every component in the original prototype, a cloned component will be created in this prototype
		*    - The newly created components will not be started (via startup() method)
		*/
		void cloneComponentsFrom(const Prototype& originalPrototype, bool copyOverrideState);

		//[-------------------------------------------------------]
		//[ Misc                                                  ]
		//[-------------------------------------------------------]
		inline uint8 getComponentChangesCount() const;


	//[-------------------------------------------------------]
	//[ Protected methods                                     ]
	//[-------------------------------------------------------]
	protected:
		/**
		*  @brief
		*    Constructor
		*
		*  @param[in] id
		*    The unique prototype identifier
		*  @param[in] manager
		*    The manager this prototype is in
		*
		*  @note
		*    - Use "qsf::PrototypeManager::createPrototypeById()" to create a prototype instance
		*/
		inline Prototype(uint64 id, BasePrototypeManager& manager);

		/**
		*  @brief
		*    Register the given component
		*
		*  @param[in] component
		*    Component to register
		*
		*  @note
		*    - Does not check whether or not the component is already registered
		*    - Also registeres the component under the base class IDs down to "qsf::Component" (but not "qsf::Component" itself),
		*      for example "qsf::MeshComponent" also registers itself under "qsf::RendererComponent"
		*/
		void registerComponent(Component& component);

		/**
		*  @brief
		*    Called in case a component property value was changed
		*
		*  @param[in] component
		*    Component instance which had a property value change
		*  @param[in] propertyId
		*    Unique class property ID the component property which values was changed
		*
		*  @note
		*    - The unique class property identifier is generated by "qsf::StringHash" by using the class property name
		*      (e.g. qsf::StringHash("Position") generating the hash value 3091144222)
		*/
		void onComponentPropertyChange(Component& component, uint32 propertyId);

		/**
		*  @brief
		*    React to component transform changes
		*
		*  @param[in] transformComponent
		*    The transform component holding the changes transformation
		*  @param[in] transform
		*    The changed transform
		*  @param[in] flags
		*    Flags describing the change, see "qsf::Component::TransformChangeFlag"
		*/
		void onComponentTransformChange(TransformComponent& transformComponent, const Transform& transform, uint8 flags);


	//[-------------------------------------------------------]
	//[ Private methods                                       ]
	//[-------------------------------------------------------]
	private:
		Component* internalCreateComponent(const StringHash& id, const std::string* values, bool startup);
		Component* internalStartupAndRegisterComponent(Component& component, bool startup);


	//[-------------------------------------------------------]
	//[ Protected definitions                                 ]
	//[-------------------------------------------------------]
	protected:
		/**
		*  @brief
		*    Prototype flags
		*/
		enum Flags
		{
			ENTITY					= 1<<0,	///< This flag indicates that the prototype is in fact an entity
			SERIALIZABLE			= 1<<1,	///< This flag indicates that the prototype is serializable; does not make conceptional sense for prototypes and therefore the flag getter and setter are defined in the entity class
			IGNORE_PROPERTY_CHANGES	= 1<<2	///< If set, component property changes are not passed to the components, but simply ignored
		};
		typedef BitFlagSet<uint8, Flags> FlagSet;

		typedef std::vector<Component*>				   ComponentList;
		typedef std::unordered_map<uint32, Component*> ComponentMap;


	//[-------------------------------------------------------]
	//[ Protected data                                        ]
	//[-------------------------------------------------------]
	protected:
		uint64					mId;					///< The unique prototype identifier inside the associated manager
		BasePrototypeManager*	mManager;				///< The manager this prototype is registered in
		ComponentList			mComponentList;			///< Component list
		ComponentMap			mComponentMap;			///< Component map with unique component identifier as key and pointer to the component as value
		ComponentList			mListenerComponents;	///< List of components that can be listeners to component property changes (see "onComponentPropertyChange")
		FlagSet					mFlags;					///< Internal flags, see "qsf::Prototype::Flags"
		uint8					mComponentChangesCount;	///< An "counter" which is used to "track" if any changes to the component list (add/remove) where done


	//[-------------------------------------------------------]
	//[ CAMP reflection system                                ]
	//[-------------------------------------------------------]
	QSF_CAMP_RTTI()	// Only adds the virtual method "campClassId()", nothing more


	};


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
} // qsf


//[-------------------------------------------------------]
//[ Implementation                                        ]
//[-------------------------------------------------------]
#include "qsf/prototype/Prototype-inl.h"


//[-------------------------------------------------------]
//[ CAMP reflection system                                ]
//[-------------------------------------------------------]
QSF_CAMP_TYPE_NONCOPYABLE(qsf::Prototype)
