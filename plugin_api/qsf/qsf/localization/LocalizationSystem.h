// Copyright (C) 2012-2017 Promotion Software GmbH


//[-------------------------------------------------------]
//[ Header guard                                          ]
//[-------------------------------------------------------]
#pragma once


//[-------------------------------------------------------]
//[ Includes                                              ]
//[-------------------------------------------------------]
#include "qsf/Qsf.h"
#include "qsf/base/System.h"

#include <boost/signals2.hpp>
#include <boost/container/flat_map.hpp>

#include <vector>


//[-------------------------------------------------------]
//[ Forward declarations                                  ]
//[-------------------------------------------------------]
namespace camp
{
	class TagHolder;
}
namespace qsf
{
	class Translator;
	class LocalizationContext;
	class LocalizationMessage;
}


//[-------------------------------------------------------]
//[ Macros                                                ]
//[-------------------------------------------------------]
/**
*  @brief
*    Translate a given unique message ID
*
*  @param[in] messageId
*    Unique ID of the message to translate
*
*  @return
*    The UTF-8 translation of the given unique message ID, empty string on error, empty string in case there's no QSF instance
*
*  @note
*    - The unique message identifier is generated by "qsf::StringHash" by using the UTF-8 message
*      (e.g. qsf::StringHash("ID_QSF_ENTITY_NAME") generating the hash value 136318083)
*    - In order to reduce collisions it's recommended to use this method only with message IDs
*      generated out of ID strings like "ID_QSF_ENTITY_NAME", not message strings like "Entity"
*/
#define QSF_TRANSLATE_ID(messageId) \
	(nullptr != qsf::Qsf::instance() ? qsf::Qsf::instance()->getLocalizationSystem().messageId(messageId) : "")

/**
*  @brief
*    Translate a given message string in a given context
*
*  @param[in] context
*    Context of the message to translate
*  @param[in] message
*    UTF-8 message to translate
*
*  @return
*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error, empty string in case there's no QSF instance
*/
#define QSF_TRANSLATE_CONTEXTSTRING(context, message) \
	(nullptr != qsf::Qsf::instance() ? qsf::Qsf::instance()->getLocalizationSystem().translateByContextString(context, message) : "")

/**
*  @brief
*    Translate a given message string
*
*  @param[in] message
*    UTF-8 message to translate
*
*  @return
*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error, empty string in case there's no QSF instance
*
*  @note
*    - In order to reduce collisions it's recommended to use "QSF_TRANSLATE_CONTEXTSTRING()"
*/
#define QSF_TRANSLATE_STRING(message) \
	(nullptr != qsf::Qsf::instance() ? qsf::Qsf::instance()->getLocalizationSystem().translateByString(message) : "")

/**
*  @brief
*    Qt's "QT_TR_NOOP()"-macro enabling Qt's "lupdate"-program to find the internationalization texts
*
*  @param[in] x
*    UTF-8 message to translate
*/
#define QT_TR_NOOP(x) x


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
namespace qsf
{


	//[-------------------------------------------------------]
	//[ Classes                                               ]
	//[-------------------------------------------------------]
	/**
	*  @brief
	*    Localization system class
	*
	*  @remarks
	*    The localization system is used to translate a given text into the current active
	*    language. This is done by using the given text to translate as key within a certain
	*    group and each project can have its own translator to avoid conflicts. If the given
	*    text to translate was found within the given localization group, the translation result
	*    is returned, else the given text is returned instead.
	*
	*    The follow text provides an abstract overview the localization system classes:
	*    @verbatim
	*    - Localization system
	*      - Translator 0
	*        - Localization context 0
	*          - Localization message 0
	*          - Localization message n
	*        - Localization context n
	*          ...
	*      - Translator n
	*        ...
	*    @endverbatim
	*
	*    The follow text provides a concrete example of localization system content:
	*    @verbatim
	*    - Localization system
	*      - "qsf"
	*        - "core"
	*          - "ID_ENTITY_NAME" = "Entity"
	*          - "ID_ENTITY_DESCRIPTION" = "An entity is a concrete instance of a prototype"
	*          - "ID_COMPONENT_NAME" = "Component"
	*          - "ID_COMPONENT_DESCRIPTION" = "All component classes are derived from this component base class"
	*          ...
	*      - "editor"
	*        - "log view"
	*          - "ID_VIEW_LOG_NAME" = "Log"
	*          - "ID_VIEW_LOG_DESCRIPTION" = "Shows log messages"
	*          - "ID_VIEW_LOG_FILTER_TEXT" = "Filter"
	*          - "ID_VIEW_LOG_FILTER_TOOLTIP" = "Use the filter to only show log messages you're interested in"
	*        - "menu"
	*          - "ID_MENU_LOADMAP_NAME" = "Load Map"
	*          - "ID_MENU_LOADMAP_TOOLTIP" = "Load a new map"
	*        ...
	*    @endverbatim
	*
	*    There is the possibility of using localization indirection, i.e. forwarding a localization to another key.
	*    To use this, let the translated string start with the # character, followed by the key whose associated
	*    translation should be used, e.g. "#ID_ENTITY_NAME".
	*/
	class QSF_API_EXPORT LocalizationSystem : public System
	{


	//[-------------------------------------------------------]
	//[ Friends                                               ]
	//[-------------------------------------------------------]
		friend class LocalizationContext;
		friend class LocalizationMessage;


	//[-------------------------------------------------------]
	//[ Public Boost signals                                  ]
	//[-------------------------------------------------------]
	public:
		boost::signals2::signal<void ()> LanguageChanged;	///< This Boost signal is emitted as soon as the language was changed by using for example "qsf::LocalizationSystem::setLanguage()"


	//[-------------------------------------------------------]
	//[ Public definitions                                    ]
	//[-------------------------------------------------------]
	public:
		typedef boost::container::flat_map<uint32, LocalizationMessage*>	  MessageMap;
		typedef std::vector<LocalizationContext*>	 ContextList;
		typedef boost::container::flat_map<std::string, ContextList> ContextMap;


	//[-------------------------------------------------------]
	//[ Public methods                                        ]
	//[-------------------------------------------------------]
	public:
		/**
		*  @brief
		*    Default constructor
		*/
		inline LocalizationSystem();

		/**
		*  @brief
		*    Destructor
		*/
		inline virtual ~LocalizationSystem();

		//[-------------------------------------------------------]
		//[ Language                                              ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Return the registered language directories
		*
		*  @return
		*    The registered UTF-8 language directories
		*
		*  @remarks
		*    In case you have the following directory layout
		*    @verbatim
		*    em5/bin/x86r/em5.exe
		*    em5/data/qsf/content/localization/en
		*    em5/data/qsf/content/localization/de
		*    em5/data/em5/content/localization/en
		*    em5/data/em5/content/localization/de
		*    @endverbatim
		*    You will register the directories
		*    @verbatim
		*    em5/data/qsf/content/localization
		*    em5/data/em5/content/localization
		*    @endverbatim
		*    The localization system will now list "en" and "de" as available languages.
		*    Setting the language of the localization system by calling "qsf::LocalizationSystem::setLanguage("en")" will result
		*    in a "qsf::Localization::loadTranslatorsFromDirectory()" call for all registered language directories:
		*    @code
		*    qsf::Localization::destroyAllTranslators();
		*    qsf::Localization::loadTranslatorsFromDirectory("data/qsf/content/localization/en");
		*    qsf::Localization::loadTranslatorsFromDirectory("data/em5/content/localization/en");
		*    @endcode
		*/
		inline const std::vector<std::string>& getLanguageDirectories() const;

		/**
		*  @brief
		*    Add a directory as language directory
		*
		*  @param[in] directory
		*    The UTF-8 directory to register as language directory
		*
		*  @return
		*    "true" if all went fine, else "false" (maybe the language directory is already registered)
		*/
		bool addLanguageDirectory(const std::string& directory);

		/**
		*  @brief
		*    Remove a directory as language directory
		*
		*  @param[in] directory
		*    The UTF-8 directory to unregister as language directory
		*
		*  @return
		*    "true" if all went fine, else "false"
		*/
		void removeLanguageDirectory(const std::string& directory);

		/**
		*  @brief
		*    Return the list of available languages
		*
		*  @return
		*    The list of registered UTF-8 languages
		*
		*  @remarks
		*    The list of available languages contains all languages, even if there's a language directory not supporting
		*    a certain language. For instance
		*    @verbatim
		*    em5/data/qsf/content/localization/en
		*    em5/data/qsf/content/localization/de
		*    em5/data/em5/content/localization/en
		*    em5/data/em5/content/localization/de
		*    @endverbatim
		*    will result in the available languages "en", "de" and "ru".
		*/
		const std::vector<std::string>& getAvailableLanguages();

		/**
		*  @brief
		*    Return the currently set language
		*
		*  @return
		*    The currently set UTF-8 language, e.g. "en"
		*/
		inline const std::string& getLanguage() const;

		/**
		*  @brief
		*    Set the currently set language
		*
		*  @param[in] language
		*    The UTF-8 language to set, e.g. "en"
		*  @param[in] force
		*    If "true", the language will be applied, even in case there is no change
		*
		*  @return
		*    "true" if all went fine, else "false"
		*/
		bool setLanguage(const std::string& language, bool force = false);

		//[-------------------------------------------------------]
		//[ Translator                                            ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Load all translator files from the given directory
		*
		*  @param[in] directory
		*    UTF-8 language directory name to load all translator files from
		*  @param[in] recursive
		*    Load recursive also from sub-directories?
		*
		*  @note
		*    - Already registered translators are not destroyed before adding new ones
		*/
		void loadTranslatorsFromDirectory(const std::string& directory, bool recursive = true);

		/**
		*  @brief
		*    Create a new translator instance
		*
		*  @return
		*    The created translator instance, null pointer on error, don't destroy the returned instance
		*/
		Translator* createTranslator();

		/**
		*  @brief
		*    Destroy a given translator instance
		*
		*  @param[in] translator
		*    The translator instance to destroy, after this method call this instance is no longer valid
		*/
		void destroyTranslator(Translator& translator);

		/**
		*  @brief
		*    Destroy all translators within this localization system
		*/
		void destroyAllTranslators();

		/**
		*  @brief
		*    Return the list of currently loaded translators
		*
		*  @return
		*    Reference to the internal list of currently loaded translators, do not manipulate the list or destroy the translators
		*/
		inline const std::vector<Translator*>& getTranslators() const;

		//[-------------------------------------------------------]
		//[ Translate                                             ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Translate a given unique message ID
		*
		*  @param[in] messageId
		*    Unique ID of the message to translate
		*
		*  @return
		*    The UTF-8 translation of the given unique message ID, empty string on error
		*
		*  @note
		*    - The unique message identifier is generated by "qsf::StringHash" by using the UTF-8 message
		*      (e.g. qsf::StringHash("ID_QSF_ENTITY_NAME") generating the hash value 483975945)
		*    - In order to reduce collisions it's recommended to use this method only with message IDs
		*      generated out of ID strings like "ID_QSF_ENTITY_NAME", not message strings like "Entity"
		*/
		inline const std::string& translateById(uint32 messageId) const;

		/**
		*  @brief
		*    Translate a given message string in a given context
		*
		*  @param[in] context
		*    Context of the message to translate
		*  @param[in] string
		*    Source of the message to translate
		*
		*  @return
		*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error
		*/
		const std::string& translateByContextString(const std::string& context, const std::string& source) const;

		/**
		*  @brief
		*    Translate a given message string
		*
		*  @param[in] source
		*    Source of the message to translate
		*
		*  @return
		*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error
		*
		*  @note
		*    - In order to reduce collisions it's recommended to use "qsf::LocalizationSystem::translateByContextString()"
		*/
		inline const std::string& translateByString(const std::string& source) const;

		/**
		*  @brief
		*    Translate a given message string
		*
		*  @param[in] source
		*    Source of the message to translate
		*  @param[out] wasTranslated
		*    "true" if a translation was found, "false" if not and the output string is equal to the input
		*
		*  @return
		*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error
		*
		*  @note
		*    - In order to reduce collisions it's recommended to use "qsf::LocalizationSystem::translateByContextString()"
		*/
		inline const std::string& translateByString(const std::string& source, bool& wasTranslated) const;

		/**
		*  @brief
		*    Translate a given message string
		*
		*  @param[in] source
		*    Source of the message to translate
		*  @param[in] fallbackSource
		*    String to translate in case no translation was found for the actual source
		*
		*  @return
		*    The UTF-8 translation of the given UTF-8 message, given UTF-8 message on error
		*
		*  @note
		*    - In order to reduce collisions it's recommended to use "qsf::LocalizationSystem::translateByContextString()"
		*/
		inline const std::string& translateByStringWithFallback(const std::string& source, const std::string& fallbackSource) const;

		/**
		*  @brief
		*    Translate a given message CAMP tag string
		*
		*  @param[in] campTagHolder
		*    CAMP tag holder to use for translation
		*  @param[in] tagId
		*    Identifier (result of tag name string hashing) of the tag to get, no reference by intent
		*  @param[in] defaultValue
		*    UTF-8 default value of the CAMP tag
		*
		*  @return
		*    The UTF-8 translation of the given CAMP tag string, given UTF-8 default value on error (no reference value by intent)
		*/
		std::string translateByCampTagString(const camp::TagHolder& campTagHolder, camp::StringId id, const std::string& defaultValue = "") const;

		//[-------------------------------------------------------]
		//[ Debug                                                 ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Check for source string hash collision
		*
		*  @remarks
		*    A string hash of source strings will be calculated for more effective processing. This task
		*    is always done by "qsf::StringHash" which is using FNV-1a as hash function. By using hash
		*    values there's always the risk of a collision, meaning that multiple strings result in one
		*    and the same hash value. While the probability for this is low, you might want to call this
		*    function during development to be informed when such a collision occurs.
		*
		*  @return
		*    "true" if all went fine and there was no collision, else "false" in case at least one collision occurred
		*
		*  @note
		*    - In case there's a string hash collision, a log message will be written
		*/
		bool checkForSourceStringHashCollision() const;


	//[-------------------------------------------------------]
	//[ Public virtual qsf::System methods                    ]
	//[-------------------------------------------------------]
	public:
		inline virtual const char* getName() const override;
		//[-------------------------------------------------------]
		//[ Lifecycle                                             ]
		//[-------------------------------------------------------]
		virtual bool onStartup(bool serverMode) override;
		virtual void onShutdown() override;


	//[-------------------------------------------------------]
	//[ Private methods                                       ]
	//[-------------------------------------------------------]
	private:
		const std::string& resolveIndirection(const std::string& translation) const;


	//[-------------------------------------------------------]
	//[ Private data                                          ]
	//[-------------------------------------------------------]
	private:
		std::vector<std::string> mLanguageDirectories;	///< Registered language directories, see "qsf::LocalizationSystem::getLanguageDirectories()" comment for details
		std::vector<std::string> mAvailableLanguages;	///< Available languages, e.g. "en" and "de", see "qsf::LocalizationSystem::getLanguageDirectories()" comment for details, only use "qsf::LocalizationSystem::getAvailableLanguages()" to read-access it
		std::string				 mLanguage;				///< The currently set language, e.g. "en"
		std::vector<Translator*> mTranslators;			///< Translator instances, we're responsible for destroying the instances in case we no longer need it
		mutable MessageMap		 mMessageMap;			///< Map for direct message access, contains all messages, string hash of the message source as key, localization message as value
		mutable ContextMap		 mContextMap;			///< Map for direct context access, contains all contexts, context name key, localization context as value
		mutable uint32			 mRedirectionDepth;		///< Current ID redirection resolution depth; used for finding cycles


	};


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
} // qsf


//[-------------------------------------------------------]
//[ Implementation                                        ]
//[-------------------------------------------------------]
#include "qsf/localization/LocalizationSystem-inl.h"
