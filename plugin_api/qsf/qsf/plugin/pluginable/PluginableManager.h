// Copyright (C) 2012-2017 Promotion Software GmbH


//[-------------------------------------------------------]
//[ Header guard                                          ]
//[-------------------------------------------------------]
#pragma once


//[-------------------------------------------------------]
//[ Includes                                              ]
//[-------------------------------------------------------]
#include "qsf/base/StringHash.h"
#include "qsf/base/manager/Manager.h"
#include "qsf/reflection/CampClass.h"

#include <boost/container/flat_map.hpp>

#include <vector>


//[-------------------------------------------------------]
//[ Forward declarations                                  ]
//[-------------------------------------------------------]
namespace camp
{
	class Class;
	class UserObject;
}
namespace qsf
{
	class PluginableBase;
}


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
namespace qsf
{


	//[-------------------------------------------------------]
	//[ Classes                                               ]
	//[-------------------------------------------------------]
	/**
	*  @brief
	*    Pluginable manager base class
	*
	*  @remarks
	*    The pluginable manager is automatically able to use all CAMP classes which are derived from <type>.
	*    Pluginables are a kind of singleton which can be added dynamically in order to add new features.
	*/
	class QSF_API_EXPORT PluginableManager : public Manager
	{


	//[-------------------------------------------------------]
	//[ Public methods                                        ]
	//[-------------------------------------------------------]
	public:
		/**
		*  @brief
		*    Destructor
		*/
		virtual ~PluginableManager();

		/**
		*  @brief
		*    Return the list of all available pluginable instances
		*
		*  @return
		*    The list of all available pluginable instances, do not manipulate the list or destroy the pluginables
		*/
		inline const std::vector<PluginableBase*>& getPluginableList() const;

		/**
		*  @brief
		*    Return the list of all available pluginable instances
		*
		*  @return
		*    The list of all available pluginable instances, do not manipulate the list or destroy the pluginables
		*/
		template <typename T> const std::vector<T*>& getList() const;

		/**
		*  @brief
		*    Return a pluginable instance by using a given CAMP reflection class
		*
		*  @param[in] campClass
		*    CAMP reflection class of the pluginable to return
		*
		*  @return
		*    The requested pluginable instance, null pointer on error, do no destroy the returned instance
		*
		*  @note
		*    - Less efficient as e.g. qsf::PluginableManager::getPluginableById()"
		*/
		PluginableBase* getPluginableByCampClass(const camp::Class& campClass) const;

		/**
		*  @brief
		*    Return a pointer to a pluginable instance by using its unique identifier
		*
		*  @param[in] id
		*    The unique pluginable identifier generated by "qsf::StringHash"
		*
		*  @return
		*    The requested pluginable instance, null pointer on error, do no destroy the returned instance
		*/
		inline PluginableBase* getPluginableById(const StringHash& id) const;

		//[-------------------------------------------------------]
		//[ Unsafe access (check for null pointer)                ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Return a pointer to a pluginable instance of a certain type
		*
		*  @return
		*    The requested pluginable instance, null pointer on error, do no destroy the returned instance
		*/
		template <typename T> T* get() const;

		/**
		*  @brief
		*    Return a pointer to a pluginable instance by using its unique identifier
		*
		*  @param[in] id
		*    The unique pluginable identifier generated by "qsf::StringHash"
		*
		*  @return
		*    The requested pluginable instance, null pointer on error, do no destroy the returned instance
		*/
		template <typename T> T* getById(const StringHash& id) const;

		//[-------------------------------------------------------]
		//[ Safe access (will throw exception in case of error)   ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Return a reference to a pluginable instance of a certain type
		*
		*  @return
		*    The requested pluginable instance, do no destroy the returned instance, throws an exception in case the requested instance was not found
		*
		*  @note
		*    - It's recommended to use this "safe"-method only in case you're sure that the requested instance must exist
		*/
		template <typename T> T& getSafe() const;

		/**
		*  @brief
		*    Return a reference to a pluginable instance by using its unique identifier
		*
		*  @param[in] id
		*    The unique pluginable identifier generated by "qsf::StringHash"
		*
		*  @return
		*    The requested pluginable instance, do no destroy the returned instance, throws an exception in case the requested instance was not found
		*
		*  @note
		*    - It's recommended to use this "safe"-method only in case you're sure that the requested instance must exist
		*/
		template <typename T> T& getByIdSafe(const StringHash& id) const;


	//[-------------------------------------------------------]
	//[ Protected methods                                     ]
	//[-------------------------------------------------------]
	protected:
		/**
		*  @brief
		*    Default constructor
		*/
		PluginableManager();

		/**
		*  @brief
		*    Register all known and supported CAMP pluginable classes
		*/
		void registerPluginables();

		/**
		*  @brief
		*    Register the given CAMP pluginable class
		*
		*  @param[in] added
		*    CAMP pluginable class to register
		*
		*  @return
		*    The created pluginable instance, can be a null pointer, do not destroy the instance
		*/
		PluginableBase* registerPluginable(const camp::Class& added);

		/**
		*  @brief
		*    Insert the given pluginable in the internal data structure of the pluginable manager
		*
		*  @note
		*    - Different to registerPluginable() no new instance is created, the pluginable manager takes over the control
		*/
		void injectPluginable(uint32 id, PluginableBase& pluginableBase);


	//[-------------------------------------------------------]
	//[ Protected virtual qsf::PluginableManager methods      ]
	//[-------------------------------------------------------]
	protected:
		/**
		*  @brief
		*    Called after a new CAMP class has been registered
		*
		*  @param[in]  added
		*    New new CAMP class
		*
		*  @note
		*    - The default implementation is empty
		*/
		virtual void classAdded(const camp::Class& added);

		/**
		*  @brief
		*    Create an instance of the given CAMP pluginable class
		*
		*  @param[in]  added
		*    CAMP pluginable class to create an instance of
		*  @param[out] campUserObject
		*    CAMP user object receiving the created pluginable instance
		*/
		virtual void createPluginableInstance(const camp::Class& added, camp::UserObject& campUserObject);

		/**
		*  @brief
		*    Unregister all known and supported CAMP pluginable classes
		*
		*  @note
		*    - The default implementation deletes all pluginable instances, in case the pluginable manager
		*      does not have the ownership of the instances you might want to reimplement this method
		*/
		virtual void unregisterPluginables();


	//[-------------------------------------------------------]
	//[ Protected data                                        ]
	//[-------------------------------------------------------]
	protected:
		std::vector<PluginableBase*>						mPluginables;	///< List of all available pluginable instances, we have to destroy the instances if we no longer need them
		boost::container::flat_map<uint32, PluginableBase*> mPluginableMap;	///< Pluginable map with unique pluginable identifier as key and pointer to the pluginable as value


	//[-------------------------------------------------------]
	//[ CAMP reflection system                                ]
	//[-------------------------------------------------------]
	QSF_CAMP_RTTI()	// Only adds the virtual method "campClassId()", nothing more


	};


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
} // qsf


//[-------------------------------------------------------]
//[ Implementation                                        ]
//[-------------------------------------------------------]
#include "qsf/plugin/pluginable/PluginableManager-inl.h"


//[-------------------------------------------------------]
//[ CAMP reflection system                                ]
//[-------------------------------------------------------]
QSF_CAMP_TYPE_NONCOPYABLE(qsf::PluginableManager)
