// Copyright (C) 2012-2017 Promotion Software GmbH


//[-------------------------------------------------------]
//[ Header guard                                          ]
//[-------------------------------------------------------]
#pragma once


//[-------------------------------------------------------]
//[ Includes                                              ]
//[-------------------------------------------------------]
#include "qsf_logic/Export.h"

#include <qsf/base/manager/Manager.h>
#include <qsf/asset/AssetSystemTypes.h>

#include <boost/container/flat_map.hpp>

#include <vector>


//[-------------------------------------------------------]
//[ Forward declarations                                  ]
//[-------------------------------------------------------]
namespace qsf
{
	class StringHash;
	class CachedAsset;
	namespace logic
	{
		class Sequence;
	}
}


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
namespace qsf
{
	namespace logic
	{


		//[-------------------------------------------------------]
		//[ Classes                                               ]
		//[-------------------------------------------------------]
		/**
		*  @brief
		*    Sequence manager class
		*
		*  @remarks
		*    In order to create sequences via code write
		*    @code
		*    qsf::logic::Sequence* sequence = QSF_LOGIC_SEQUENCE.createNewSequenceByLocalAssetId("sample/sequence/cutscene/intro");
		*    // ... sequence null pointer check would be a good idea ...
		*    uint64 newSequenceId = sequence->getId();	// "qsf::getUninitialized<uint64>()" if invalid sequence ID
		*    @endcode
		*
		*    The following example shows how to get the instance of a certain sequence:
		*    @code
		*    // uint64 mySequenceId = ...
		*    qsf::logic::Sequence* sequence = QSF_LOGIC_SEQUENCE.getSequenceByLocalAssetId(mySequenceId);
		*    @endcode
		*
		*    Use "qsf::logic::SequencePlayer" for sequence playback.
		*
		*  @todo
		*    - TODO(co) As far as I can tell at the moment, there's no need for a sequence manager because the sequence system could also do this job
		*/
		class QSF_LOGIC_API_EXPORT SequenceManager : public Manager
		{


		//[-------------------------------------------------------]
		//[ Friends                                               ]
		//[-------------------------------------------------------]
			friend class SequenceSystem;	// Only the sequencer system is allowed to create/destroy sequence manager instances


		//[-------------------------------------------------------]
		//[ Public definitions                                    ]
		//[-------------------------------------------------------]
		public:
			typedef std::vector<Sequence*> SequenceVector;


		//[-------------------------------------------------------]
		//[ Public methods                                        ]
		//[-------------------------------------------------------]
		public:
			/**
			*  @brief
			*    Create a new and empty sequence instance
			*
			*  @param[in] id
			*    The ID to assign to the new sequence
			*
			*  @return
			*    The created sequence instance, null pointer on error (unique sequence identifier already used?), do no destroy the returned
			*    instance and do need keep a reference to it outside the C runtime stack (use the unique sequence ID instead)
			*
			*  @note
			*    - The new sequence instance has no tracks at all
			*/
			Sequence* createNewSequenceById(uint64 id);

			/**
			*  @brief
			*    Destroy a sequence instance by using its ID
			*
			*  @param[in] id
			*    The ID of the sequence to destroy
			*
			*  @return
			*    "true" if all went fine, else "false" (unknown sequence identifier?)
			*/
			bool destroySequenceById(uint64 id);

			/**
			*  @brief
			*    Destroy a sequence instance by using its local asset name
			*
			*  @param[in] localAssetName
			*    The local asset name of the sequence to destroy, for example "sample/sequence/cutscene/intro"
			*
			*  @return
			*    "true" if all went fine, else "false" (unknown local asset name?)
			*/
			bool destroySequenceByLocalAssetName(const StringHash& localAssetName);

			/**
			*  @brief
			*    Destroy all sequences within this sequence system
			*/
			void destroyAllSequences();

			/**
			*  @brief
			*    Change a sequences ID
			*
			*  @note
			*    - Use with care: all references to the old sequence ID will become invalid
			*/
			bool changeSequenceId(uint64 oldId, uint64 newId);

			/**
			*  @brief
			*    Return a sequence instance by using its local asset ID
			*
			*  @param[in] id
			*    The sequence ID generated by "qsf::StringHash" (example: "sample/sequence/default/intro")
			*
			*  @return
			*    The requested sequence instance, null pointer on error
			*/
			inline Sequence* getSequenceById(uint64 id) const;

			/**
			*  @brief
			*    Return the list of currently instanced sequences
			*
			*  @return
			*    Reference to the internal list of currently instanced sequences, do not manipulate the list or destroy the sequences
			*/
			inline const SequenceVector& getSequences() const;

			/**
			*  @brief
			*    Return a sequence name that is not used by another sequence
			*
			*  @param[in] firstPart
			*    The first part of the desired sequence name, it will be expanded by a number
			*
			*  @return
			*    A free name that can be used for a new sequence
			*/
			std::string generateUnusedSequenceName(const std::string& firstPart);

			/**
			*  @brief
			*    Return a sequence instance by using its local asset ID
			*
			*  @param[in] stringHash
			*    The local sequence asset ID generated by "qsf::StringHash" (example: "sample/sequence/cutscene/intro")
			*  @param[in] load
			*    In case the sequence is not loaded, yet, do automatically load it?
			*
			*  @return
			*    The requested sequence instance, null pointer on error, do not destroy the returned instance
			*
			*  @note
			*    - In case there's no instance of the given local asset, yet, an instance will be created on-the-fly
			*/
			Sequence* getSequenceByLocalAssetId(const StringHash& stringHash, bool load = true);


		//[-------------------------------------------------------]
		//[ Private methods                                       ]
		//[-------------------------------------------------------]
		private:
			/**
			*  @brief
			*    Default constructor
			*/
			SequenceManager();

			/**
			*  @brief
			*    Destructor
			*/
			virtual ~SequenceManager();

			Sequence* loadSequenceByCachedAsset(const CachedAsset& cachedAsset);


		//[-------------------------------------------------------]
		//[ Private definitions                                   ]
		//[-------------------------------------------------------]
		private:
			typedef boost::container::flat_map<uint64, LocalAssetId>	SequenceIdMap;
			typedef boost::container::flat_map<LocalAssetId, Sequence*> MainSequenceMap;
			typedef boost::container::flat_map<uint64, Sequence*>		SequenceMap;


		//[-------------------------------------------------------]
		//[ Private data                                          ]
		//[-------------------------------------------------------]
		private:
			SequenceVector	mSequenceList;		///< List of all sequences within the map
			SequenceMap		mSequenceMap;		///< Sequence map with unique sequence identifier as key and pointer to the sequence as value
			SequenceIdMap	mSequenceIdMap;		///< Sequence map with unique sequence identifier as key and sequence local asset ID as value
			MainSequenceMap	mMainSequenceMap;	///< Sequence map with sequence local asset ID as key and sequence as value


		};


//[-------------------------------------------------------]
//[ Namespace                                             ]
//[-------------------------------------------------------]
	} // logic
} // qsf


//[-------------------------------------------------------]
//[ Implementation                                        ]
//[-------------------------------------------------------]
#include "qsf_logic/sequence/SequenceManager-inl.h"
